<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Showcase Template</title><link>https://joluva.github.io/showcase/docs/visual-Illusions/masking/</link><description>Recent content on Showcase Template</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://joluva.github.io/showcase/docs/visual-Illusions/masking/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://joluva.github.io/showcase/docs/visual-Illusions/masking/convolution/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://joluva.github.io/showcase/docs/visual-Illusions/masking/convolution/</guid><description>Convolution and histogram # p5-iframe markdown {{&amp;lt; p5-iframe sketch=&amp;#34;/showcase/sketches/histogram.js&amp;#34; width=&amp;#34;780&amp;#34; height=&amp;#34;1000&amp;#34; &amp;gt;}} Code # var red_arr = new Array(256); var green_arr = new Array(256); var blue_arr = new Array(256); var showFilter = false; var inp; let filter = [ [-2, -1, 0], [-1, 1, 1], [0, 1, 2] ]; var colors = new Array(3); var leftM = 30; var upM = 15; function preload() { img = loadImage(&amp;#34;/showcase/sketches/lennna.jpg&amp;#34;); } function getIndex(x, y) { return (x + y * img.</description></item><item><title/><link>https://joluva.github.io/showcase/docs/visual-Illusions/masking/kinegram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://joluva.github.io/showcase/docs/visual-Illusions/masking/kinegram/</guid><description>Kinegram # p5-iframe markdown {{&amp;lt; p5-iframe sketch=&amp;#34;/showcase/sketches/kg.js&amp;#34; width=&amp;#34;625&amp;#34; height=&amp;#34;625&amp;#34; &amp;gt;}} Código # new p5((p)=&amp;gt;{ let lenna; let y = 0; p.preload = function() { mask = p.loadImage(&amp;#39;/showcase/sketches/o33t.png&amp;#39;); ring = p.loadImage(&amp;#39;/showcase/sketches/rings.png&amp;#39;); wheel = p.loadImage(&amp;#39;/showcase/sketches/wheel.png&amp;#39;); } p.setup = function() { p.createCanvas(600, 600); mask.resize(900,700); ring.resize(700,800); wheel.resize(700,800); } p.draw = function() { p.background(255); p.image(ring,100,-20); p.image(wheel,100,250); p.image(mask, -30, p.mouseY-150); } },&amp;#34;kg&amp;#34;) Problema a resolver # Implementar un kinegrama.
Concepto # En términos de ilusiones visuales, un kinegrama es una técnica que crea la ilusión de movimiento a través de una serie de imágenes estáticas.</description></item><item><title/><link>https://joluva.github.io/showcase/docs/visual-Illusions/masking/lightness/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://joluva.github.io/showcase/docs/visual-Illusions/masking/lightness/</guid><description>Lightness variation # p5-iframe markdown {{&amp;lt; p5-iframe sketch=&amp;#34;/showcase/sketches/lightness.js&amp;#34; width=&amp;#34;700&amp;#34; height=&amp;#34;900&amp;#34; &amp;gt;}} Code # let img; let brightness_reduction = 0; function calculate_hue(r_prime, g_prime, b_prime) { // Geometric method let c_max = max(r_prime, g_prime, b_prime); // max of r&amp;#39;, g&amp;#39;, b&amp;#39; let c_min = min(r_prime, g_prime, b_prime); // min of r&amp;#39;, g&amp;#39;, b&amp;#39; let delta = c_max - c_min; // delta rgb let h = 0; let s = 0; if (delta == 0) { h = 0; // Can be any color } else if (c_max == r_prime) { h = 60 * (((g_prime - b_prime) / delta) % 6); } else if (c_max == g_prime) { h = 60 * ((b_prime - r_prime) / delta + 2); } else if (c_max == b_prime) { h = 60 * ((r_prime - g_prime) / delta + 4); } if (c_max) { s = delta / c_max; } return h; } function calculate_saturation(r_prime, g_prime, b_prime) { // Distance from center to max let c_max = max(r_prime, g_prime, b_prime); // max of r&amp;#39;, g&amp;#39;, b&amp;#39; let c_min = min(r_prime, g_prime, b_prime); // min of r&amp;#39;, g&amp;#39;, b&amp;#39; let delta = c_max - c_min; // delta rgb let s = 0; if (c_max) { s = 1 - c_min / c_max; } return s * 100; } function calculate_hsl_saturation(r_prime, g_prime, b_prime) { // Distance from center to max let c_max = max(r_prime, g_prime, b_prime); // max of r&amp;#39;, g&amp;#39;, b&amp;#39; let c_min = min(r_prime, g_prime, b_prime); // min of r&amp;#39;, g&amp;#39;, b&amp;#39; let delta = c_max - c_min; // delta rgb let s = 0; if (calculate_lightness(r_prime, g_prime, b_prime) !</description></item><item><title/><link>https://joluva.github.io/showcase/docs/visual-Illusions/masking/moire-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://joluva.github.io/showcase/docs/visual-Illusions/masking/moire-pattern/</guid><description>Moiré pattern # p5-iframe markdown {{&amp;lt; p5-iframe sketch=&amp;#34;/showcase/sketches/moire.js&amp;#34; width=&amp;#34;625&amp;#34; height=&amp;#34;625&amp;#34; &amp;gt;}} Code # new p5((p)=&amp;gt;{ let rotation = 0; p.preload = function() { mask = p.loadImage(&amp;#39;/showcase/sketches/o33t.png&amp;#39;); mask2 = p.loadImage(&amp;#39;/showcase/sketches/o33t.png&amp;#39;); } p.setup = function() { p.createCanvas(600, 600); mask.resize(500,500); mask2.resize(500,500); p.imageMode(p.CENTER); p.angleMode(p.DEGREES); } p.draw = function() { p.background(255); p.image(mask2,p.width / 2,p.height / 2); p.translate(p.width / 2, p.height / 2); p.rotate(rotation); p.image(mask, 0, 0); rotation +=1; } },&amp;#34;moire&amp;#34;) Problema a resolver # Implementar un patrón de Moiré.</description></item></channel></rss>